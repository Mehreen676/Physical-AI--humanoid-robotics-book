---
id: ContentPersonalizer
name: Content Personalizer
type: skill
version: 1.0.0
category: personalization
tags: [adaptation, user-profile, dynamic-content, mdx]
---

# ContentPersonalizer Skill

## Purpose
Personalizes chapter content based on user's software/hardware background and learning goal. Adapts depth, examples, and pacing to match user expertise level while preserving all learning outcomes and core concepts.

## Inputs

```yaml
original_content:
  type: string (MDX)
  description: "Original (neutral/baseline) chapter content"
  required: true

user_background:
  type: object
  required: true
  properties:
    software_level:
      type: string
      enum: [beginner, intermediate, advanced]
      description: "Programming/ROS 2 experience level"
    hardware_level:
      type: string
      enum: [none, basic, extensive]
      description: "Robotics hardware experience"
    learning_goal:
      type: string
      enum: [fundamentals, specialization, research]
      description: "Primary learning objective"
    preferred_language:
      type: string
      enum: [en, ur]
      description: "Content language preference"
      default: en

personalization_level:
  type: string
  enum: [light, moderate, heavy]
  description: "How much to adapt content"
  default: moderate
  required: false
```

## Output

Adapted MDX content that:
- Simplifies explanations for beginners; deepens for advanced users
- Adds/removes hardware-focused examples based on hardware experience
- Includes contextual analogies matched to background
- Adjusts code complexity (Python for beginners, C++ for advanced)
- Focuses on relevant specialization path (fundamentals vs. research)
- Preserves all learning outcomes
- Maintains MDX syntax integrity

## Adaptation Rules

### 1. Software Level Adaptation

#### Beginner (Python basics, no ROS 2 experience)
- ✅ Start with analogies and simple explanations
- ✅ Provide full code boilerplate (imports, main function skeleton)
- ✅ Include "why we do this" explanations
- ✅ Use print debugging examples
- ✅ Add glossary of common ROS 2 terms
- ❌ Remove C++ examples (replace with Python)
- ❌ Skip optimization discussions
- ❌ Omit research-level theory

Example transformation:
```
Original: "Topics use QoS profiles to manage reliability..."
→ Beginner: "Topics use something called 'QoS' (Quality of Service)
           to decide how reliable the message delivery should be.
           Think of it like choosing between a phone call (reliable,
           waits for response) and a text message (faster, but might
           not get through). ROS 2 topics use QoS to let you choose
           what's best for your use case."
```

#### Intermediate (ROS 2 familiar, Python/C++)
- ✅ Include both Python and C++ options
- ✅ Discuss design trade-offs
- ✅ Add performance considerations
- ✅ Include best practices
- ❌ Don't repeat basic definitions
- ❌ Skip oversimplified analogies

#### Advanced (ROS 2 expert, research familiar)
- ✅ Include research papers and citations
- ✅ Discuss edge cases and optimization strategies
- ✅ Add C++-only or advanced patterns
- ✅ Include performance benchmarks
- ✅ Discuss concurrency, thread safety, etc.
- ✅ Assume familiarity with DDS concepts
- ❌ Don't explain ROS 2 basics

### 2. Hardware Level Adaptation

#### None (No robotics hardware experience)
- ✅ Use simulation-only examples
- ✅ Explain what sensors/actuators do conceptually
- ✅ Focus on software concepts
- ❌ Remove hardware assembly instructions
- ❌ Skip specific robot model details
- Example: Instead of "calibrate the arm's joints", say "in simulation, this calibration step ensures the virtual arm knows its correct position"

#### Basic (Assembled pre-built robots)
- ✅ Include practical setup instructions
- ✅ Add troubleshooting for common hardware issues
- ✅ Discuss sensor calibration, actuator limits
- ✅ Include simulation AND hardware examples
- ✅ Add safety warnings

#### Extensive (Built custom robots)
- ✅ Discuss custom URDF/hardware configuration
- ✅ Include URDF authoring examples
- ✅ Add advanced integration patterns
- ✅ Include hardware-specific optimizations
- ✅ Discuss ROS 2 packages for your platform

### 3. Learning Goal Adaptation

#### Fundamentals
- ✅ Progressive structure, build on prior concepts
- ✅ Comprehensive coverage of basics
- ✅ Emphasize understanding over optimization
- ❌ Don't assume research background

#### Specialization
- ✅ Focus on module-specific depth (e.g., advanced Isaac Sim skills)
- ✅ Include specialization-specific code patterns
- ✅ Add domain-specific best practices
- ✅ Include case studies from industry

#### Research
- ✅ Include research directions and open problems
- ✅ Add academic references
- ✅ Discuss cutting-edge approaches
- ✅ Include reproducible experiments
- ✅ Point to future work opportunities

### 4. Combined Personalization Example

**User Profile**: `{software: beginner, hardware: none, goal: fundamentals}`

Adaptations applied:
1. Remove C++ code examples → Python only
2. Add detailed explanations → Beginner-friendly language, analogies
3. Remove hardware config → Focus on simulation setup
4. Remove research refs → Focus on core concepts
5. Add troubleshooting tips → Common beginner mistakes
6. Add glossary → ROS 2 terminology
7. Simplify quiz questions → Focus on comprehension over edge cases

**Result**: Chapter that a Python programmer without robotics background can follow confidently to understand ROS 2 fundamentals through Gazebo simulation.

## Implementation Strategy

### Tagging for Personalization (in original content)
```mdx
<BeginnerOnly>
Beginner explanation with analogy
</BeginnerOnly>

<AdvancedOnly>
Advanced optimization discussion, edge cases, research context
</AdvancedOnly>

<HardwareExample>
This part is for users with hardware experience
</HardwareExample>

<SimulationOnly>
This is for simulation-only users
</SimulationOnly>

<ResearchGoal>
Research direction and references
</ResearchGoal>
```

Personalizer processes tags:
- Removes `<BeginnerOnly>` tags for intermediate/advanced users
- Removes `<AdvancedOnly>` for beginners
- Adapts examples based on hardware level
- Adjusts quiz difficulty

### Personalization Levels

| Aspect | Light | Moderate | Heavy |
|--------|-------|----------|-------|
| Explanation depth | Minor adjustments | Rewrite sections | Full restructure |
| Code examples | Filter language | Change examples | Rewrite all code |
| Advanced topics | Hide if beginner | Include but secondary | Highlight or expand |
| Quiz difficulty | Same quiz | Adjust questions | Different quiz |
| References | All included | Filter by level | Curated for user |

## Quality Assurance

✅ **Must Preserve**
- All learning outcomes (exactly as stated)
- Core concepts (all must be covered, depth varies)
- MDX syntax integrity
- Code functionality (logic unchanged)
- External links and references

✅ **Must Adapt**
- Explanation complexity
- Code language (Python vs C++)
- Examples relevance to user
- Quiz difficulty
- Reading level

## Usage Examples

### Example 1: Beginner Simulation User
```
Input:
  original_content: [Generic ROS 2 Topics chapter]
  user_background:
    software_level: beginner
    hardware_level: none
    learning_goal: fundamentals
  personalization_level: moderate

Output:
  - All C++ examples removed
  - Detailed Python explanations added
  - Hardware sections removed → simulation focus
  - Beginner-friendly quiz with 3-4 concepts per question
  - Glossary of ROS 2 terms added
  - Troubleshooting section for common beginner mistakes
```

### Example 2: Advanced Researcher
```
Input:
  original_content: [NVIDIA Isaac advanced physics chapter]
  user_background:
    software_level: advanced
    hardware_level: extensive
    learning_goal: research
  personalization_level: heavy

Output:
  - Beginner explanations removed
  - Research papers and citations added
  - Hardware integration patterns highlighted
  - Edge cases and optimization discussed
  - Advanced quiz with 5+ concepts per question
  - Research directions and open problems section
```

## Integration
Part of @AuthPersonalizer subagent workflow. Triggered when:
1. User signs up and provides background (initial personalization)
2. User changes preferences (adaptive personalization)
3. User completes module (can trigger re-personalization)

Supports bonus goal: content adaptation based on user profile.

## Performance Targets
- Personalization latency: < 1 second (cached for repeated users)
- Learning outcome coverage: 100% (all users see all outcomes)
- Readability improvement: 20-40% better for matched users (measured by comprehension tests)

