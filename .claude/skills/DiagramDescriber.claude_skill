---
id: DiagramDescriber
name: Diagram Describer
type: skill
version: 1.0.0
category: visualization
tags: [diagrams, ascii, mermaid, visualization, mdx]
---

# DiagramDescriber Skill

## Purpose
Creates detailed diagram descriptions and generates ASCII art or Mermaid diagrams for complex robotics and AI concepts. Produces MDX-compatible diagram code that visualizes system architecture, workflows, data flows, and conceptual relationships.

## Inputs

```yaml
concept:
  type: string
  description: "Concept to visualize (e.g., 'ROS 2 pub-sub architecture', 'URDF joint hierarchy', 'RAG pipeline', 'perception stack')"
  required: true

diagram_type:
  type: string
  enum: [architecture, flowchart, sequence, class, state, network, tree, data-flow]
  description: "Type of diagram best suited for the concept"
  required: true

detail_level:
  type: string
  enum: [high-level, detailed, comprehensive]
  description: "How much detail to include"
  default: detailed
  required: false

context:
  type: object
  description: "Context for the diagram"
  properties:
    topic: string
    chapter: string
    audience_level: string (enum: beginner, intermediate, advanced)
  required: false

format:
  type: string
  enum: [mermaid, ascii, both]
  description: "Output format"
  default: mermaid
  required: false
```

## Output Formats

### 1. Mermaid Diagram (Preferred for MDX)
Mermaid syntax that renders in browser:

```mermaid
graph TD
    A["ROS 2 Node A<br/>Publisher"] -->|Topic: /sensor_data| B["ROS 2 Middleware<br/>DDS Layer"]
    C["ROS 2 Node B<br/>Subscriber"] -->|Subscribe| B
    B -->|Message| C

    style A fill:#4A90E2
    style C fill:#7ED321
    style B fill:#F5A623
```

### 2. ASCII Diagram (Fallback/Detailed)
Text-based diagram for terminal or complex layouts:

```
┌─────────────────────────────────────────────────────────┐
│                  ROS 2 Architecture                      │
├─────────────────────────────────────────────────────────┤
│                                                           │
│  ┌──────────┐     ┌──────────┐     ┌──────────┐        │
│  │  Node A  │     │  Node B  │     │  Node C  │        │
│  │Publisher │     │Subscriber│     │Subscriber│        │
│  └────┬─────┘     └────┬─────┘     └────┬─────┘        │
│       │                │                │               │
│       └────────────────┼────────────────┘               │
│                        │                                │
│                    ┌───▼───┐                           │
│                    │ Topic │                           │
│                    │/sensor│                           │
│                    │_data  │                           │
│                    └───────┘                           │
│                        │                                │
│            ┌───────────┴───────────┐                   │
│            │                       │                   │
│        ┌───▼──┐              ┌────▼──┐               │
│        │Buffer│              │Buffer │               │
│        │ NodeB│              │ NodeC │               │
│        └──────┘              └───────┘               │
│                                                           │
│            [DDS Middleware Layer]                        │
│                                                           │
└─────────────────────────────────────────────────────────┘
```

### 3. Description Document
Structured description of the diagram:

```markdown
## ROS 2 Publish-Subscribe Architecture

### Overview
This diagram illustrates the core communication pattern in ROS 2, where:
- **Nodes** are independent processes
- **Topics** are named communication channels
- **Publishers** send messages to topics
- **Subscribers** receive messages from topics
- **DDS Middleware** handles message distribution

### Components
1. **Node A (Publisher)**: Generates and publishes sensor data
2. **Topic (/sensor_data)**: Named channel for messages
3. **Nodes B & C (Subscribers)**: Receive and process data
4. **DDS Layer**: Ensures message delivery (QoS-dependent)

### Data Flow
Publisher → Topic → DDS Middleware → Subscribers' Buffers

### Key Features
- Asynchronous communication (publisher doesn't wait)
- One-to-many (one publisher, multiple subscribers)
- Decoupled (nodes don't need to know each other)
- QoS-configurable (reliability, latency trade-offs)
```

## Diagram Types & Use Cases

### 1. Architecture Diagrams
**When**: System components and their relationships
**Example**: ROS 2 system with multiple nodes, topics, services
**Format**: Mermaid graph or ASCII box diagrams

```mermaid
graph LR
    subgraph Robot["Robot System"]
        SensorNode["Sensor Node"]
        ControlNode["Control Node"]
        ActuatorNode["Actuator Node"]
    end

    subgraph External["External Systems"]
        SimGazebo["Gazebo Sim"]
        VisionModel["Vision Model"]
    end

    SensorNode -->|/camera| SimGazebo
    VisionModel -->|/objects| ControlNode
    ControlNode -->|/commands| ActuatorNode
```

### 2. Flowchart Diagrams
**When**: Process flows, decision trees, state machines
**Example**: RAG pipeline, robot task planning
**Format**: Mermaid flowchart

```mermaid
flowchart TD
    A["User Question"] --> B["Embed Query"]
    B --> C["Search Qdrant"]
    C --> D["Retrieve Top-5 Docs"]
    D --> E["Format Context"]
    E --> F["Call GPT-4"]
    F --> G["Generate Answer"]
    G --> H["Return + Sources"]
```

### 3. Sequence Diagrams
**When**: Time-ordered interactions between components
**Example**: Service request-reply, multi-step workflows
**Format**: Mermaid sequence

```mermaid
sequenceDiagram
    Client->>Server: Request (move_arm to position)
    activate Server
    Server->>Robot: Execute movement
    activate Robot
    Robot->>Robot: Check collision
    Robot->>Server: Movement complete
    deactivate Robot
    Server->>Client: Response (success)
    deactivate Server
```

### 4. Class/Data Structure Diagrams
**When**: Object hierarchies, data relationships
**Example**: URDF kinematic tree, ROS 2 message types
**Format**: Mermaid class diagram or ASCII tree

```
robot
├── link: base
├── joint: base_to_arm (revolute)
│   └── link: arm_segment_1
│       ├── joint: arm_1_to_2 (revolute)
│       │   └── link: arm_segment_2
│       │       └── joint: arm_2_to_gripper (prismatic)
│       │           └── link: gripper
│       └── joint: arm_1_sensor (fixed)
│           └── link: camera_link
└── joint: base_to_wheel_left (continuous)
    └── link: wheel_left
```

### 5. State Machine Diagrams
**When**: State transitions, behavior trees
**Example**: Robot task states, mode switching
**Format**: Mermaid state diagram

```mermaid
stateDiagram-v2
    [*] --> Idle
    Idle --> Initializing: Power On
    Initializing --> Ready: Init Complete
    Ready --> Moving: Move Command
    Moving --> Ready: Done
    Ready --> Error: Fault Detected
    Error --> Ready: Reset
    Ready --> [*]: Power Off
```

### 6. Network/System Diagrams
**When**: Node topology, communication networks
**Example**: Multi-robot coordination, sensor networks
**Format**: Mermaid graph

```mermaid
graph TB
    subgraph Robot1["Robot 1"]
        N1A["Control Node"]
        N1B["Perception"]
    end

    subgraph Robot2["Robot 2"]
        N2A["Control Node"]
        N2B["Perception"]
    end

    CentralHub["Central Planner"]

    N1A <-->|/coordination| CentralHub
    N2A <-->|/coordination| CentralHub
    N1B <-->|/shared_map| N2B
```

## Quality Standards

✅ **Mandatory**
- Clear title and caption for each diagram
- All components labeled with meaningful names
- Legend provided for symbols/colors (if needed)
- MDX syntax valid (if Mermaid)
- Diagram readable at both desktop and mobile sizes
- Aligns with chapter content and learning outcomes
- High contrast (dark text on light, or vice versa)

✅ **Recommended**
- Accompanying prose explanation (what the diagram shows, why it matters)
- Color coding for related components or data types
- Progressive complexity (high-level first, then detailed)
- Examples of inputs/outputs if applicable
- Comparison diagrams showing alternatives

## Common Diagram Templates

### ROS 2 Pub-Sub Template
```mermaid
graph LR
    A["Publisher<br/>Node"] -->|Topic| B["DDS<br/>Middleware"]
    B --> C["Subscriber 1"]
    B --> D["Subscriber 2"]
```

### RAG Pipeline Template
```mermaid
graph LR
    A["Query"] --> B["Embedding"]
    B --> C["Vector Search<br/>Qdrant"]
    C --> D["Retrieve<br/>Top-K"]
    D --> E["Augment<br/>Prompt"]
    E --> F["LLM<br/>GPT-4"]
    F --> G["Answer"]
```

### System Architecture Template
```mermaid
graph TB
    subgraph Perception["Perception"]
        Camera["Camera"]
        Lidar["Lidar"]
    end

    subgraph Processing["Processing"]
        VLA["Vision-Language Model"]
        Planner["Motion Planner"]
    end

    subgraph Control["Control"]
        ROS["ROS 2 Stack"]
        Motors["Motor Controllers"]
    end

    Perception --> Processing
    Processing --> Control
    Control --> Motors
```

## Usage Examples

### Example 1: ROS 2 Pub-Sub Diagram
```
Input:
  concept: "ROS 2 Publisher-Subscriber Pattern"
  diagram_type: architecture
  detail_level: detailed
  format: mermaid
  audience_level: beginner

Output:
  - Mermaid diagram showing Publisher → Topic → Subscribers
  - Color-coded components
  - Alt text for accessibility
  - Prose explanation (2-3 sentences)
```

### Example 2: Complex Simulation Stack
```
Input:
  concept: "Isaac Sim + ROS 2 + Perception Pipeline"
  diagram_type: architecture
  detail_level: comprehensive
  format: both (Mermaid + ASCII)
  audience_level: advanced

Output:
  - Mermaid diagram of full system
  - ASCII fallback for text documents
  - Detailed description with data flows
  - Legend explaining QoS, communication protocols
```

## MDX Integration

```mdx
<Diagram
  title="ROS 2 Publisher-Subscriber Architecture"
  description="Shows how publishers, topics, and subscribers interact in ROS 2"
  type="mermaid"
  source={`
    graph LR
      A["Publisher"] -->|Topic| B["DDS"]
      B --> C["Subscriber 1"]
      B --> D["Subscriber 2"]
  `}
/>

Or with ASCII fallback:

<Diagram
  title="URDF Joint Hierarchy"
  type="ascii"
  source={`
    robot
    ├── link: base
    ├── joint: base_to_arm
    │   └── link: arm
    │       └── joint: arm_to_gripper
    │           └── link: gripper
  `}
/>
```

## Integration

Part of @Educator workflow. Generated alongside chapter content. One diagram per major concept section. Used to improve comprehension and break up text-heavy content.

## Success Metrics
- ✅ 100% MDX/Mermaid syntax valid
- ✅ Diagrams render correctly on desktop and mobile
- ✅ Reader comprehension improves by 30%+ with diagrams
- ✅ Accessibility: Alt text provided, high contrast
- ✅ Consistency: Diagram style/color scheme uniform across chapters

